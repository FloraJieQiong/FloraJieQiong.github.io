<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">John Doe</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/framework/" style="font-size: 10px;">framework</a> <a href="/tags/数据结构/" style="font-size: 20px;">数据结构</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">FloraJieQiong</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">John Doe</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">John Doe</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-数据结构3-树-上-——3-3-二叉树的遍历" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/04/数据结构3-树-上-——3-3-二叉树的遍历/" class="article-date">
  	<time datetime="2015-12-04T01:53:17.000Z" itemprop="datePublished">2015-12-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/04/数据结构3-树-上-——3-3-二叉树的遍历/">数据结构3-树-上-——3-3-二叉树的遍历</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据结构3-树-上-——3-2-二叉树与存储结构" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/03/数据结构3-树-上-——3-2-二叉树与存储结构/" class="article-date">
  	<time datetime="2015-12-03T04:44:51.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/03/数据结构3-树-上-——3-2-二叉树与存储结构/">数据结构3-树-上-——3-2-二叉树与存储结构</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="3-2_二叉树及存储结构">3.2 二叉树及存储结构</h1><h2 id="3-2-1_二叉树的定义">3.2.1 二叉树的定义</h2><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/314abd6ad2297a34d354aac072cbad88704b7b33/201512/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.PNG" alt="二叉树的定义"><br>(a)是空树<br>(b)只有一个结点，左子树 右子树 为空<br>(c)有左子树，右子树为空<br>(d)左子树为空，有右子树<br>(e)左子树 右子树都非空</p>
<h3 id="特殊二叉树">特殊二叉树</h3><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/591980a52b80dcea2159714719032bd2e478e923/201512/%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%911.PNG" alt="特殊二叉树1"><br>完全二叉树：有n个结点的二叉树，对 树中结点 按 从上至下、从左到右顺序 进行编号，编号为i(1 &lt;= i &lt;= n) 的结点 与 满二叉树中 编号为i的结点 在二叉树中 位置相同</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/38b39bdaf7c2ca4b1ec6e74b0b98a1761c4de1e3/201512/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%911.PNG" alt="完全二叉树1"></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/bf84cbbe47481ba0874c0f5bb6c7cceb77b066f7/201512/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%912.PNG" alt="完全二叉树2"></p>
<h3 id="二叉树的几个重要性质">二叉树的几个重要性质</h3><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/519494d1bdfc1bc1ef37647e1234a0a17882dc50/201512/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%80%A7%E8%B4%A8.PNG" alt="二叉树的几个重要性质"><br>n0表示 没有 子树的结点，n1是有一个子树的结点，n2是有2个子树的结点。</p>
<h3 id="二叉树的抽象数据类型定义">二叉树的抽象数据类型定义</h3><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/3b57a5fdd00eb6678bddbfccd4ebbcabc2a91cf2/201512/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89.PNG" alt="二叉树的抽象数据类型定义"></p>
<h2 id="3-2-2_二叉树的存储结构">3.2.2 二叉树的存储结构</h2><p><strong> 数组存储 </strong><br><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/856841d5e4f0ea618643d873f23eb730680815f1/201512/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.PNG" alt="二叉树的顺序存储"></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/18631f2efd478f41b2c58fee471550cff90d9517/201512/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%80%E8%88%AC%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt="顺序存储 一般二叉树"></p>
<p><strong> 链表存储 </strong></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/716559ce792356880ee64401109f62c5cb93c24e/201512/%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt="链表存储二叉树"></p>
<pre><code><span class="label">typedef</span> <span class="keyword">struct </span>TreeNode *<span class="keyword">BinTree;
</span><span class="label">typedef</span> <span class="keyword">BinTree </span>Position<span class="comment">;</span>
<span class="keyword">struct </span>TreeNode{
    ElementType <span class="preprocessor">Data</span><span class="comment">;</span>
    <span class="keyword">BinTree </span>Left<span class="comment">;</span>
    <span class="keyword">BinTree </span>Right<span class="comment">;</span>
}
</code></pre><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/1daaeb800bd0fc2ab8079aa728b405c4fbf80f5f/201512/%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%BE%E4%BE%8B.PNG" alt="链表存储二叉树举例"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-framework-MediaScanner" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/framework-MediaScanner/" class="article-date">
  	<time datetime="2015-12-02T07:22:05.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/framework-MediaScanner/">framework--MediaScanner</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MediaScanner">MediaScanner</h1><h2 id="涉及组件">涉及组件</h2><ul>
<li>MediaScannerService:负责扫描媒体文件，将扫描的信息插入到媒体数据库中</li>
<li>MediaProvider：处理 媒体数据库的增删改查</li>
<li>MediaScannerReceiver：接收外界发来的扫描请求，MediaScanner对外提供的接口</li>
</ul>
<h2 id="1-MediaScannerReceiver">1.MediaScannerReceiver</h2><pre><code>@Override
<span class="keyword">public</span> <span class="literal">void</span> onReceive(Context context, Intent intent) {
    final <span class="built_in">String</span> action = intent<span class="built_in">.</span>getAction();
    final Uri uri = intent<span class="built_in">.</span>getData();
    <span class="keyword">if</span> (Intent<span class="built_in">.</span>ACTION_BOOT_COMPLETED<span class="built_in">.</span><span class="keyword">equals</span>(action)) {
        <span class="comment">//接收BOOT_COMPLETED广播，扫描内部 外部存储区。</span>
        <span class="comment">//内部存储区 扫描的是/system/midia目录，存储了系统自带的铃声等媒体文件</span>
        <span class="comment">// Scan both internal and external storage</span>
        scan(context, MediaProvider<span class="built_in">.</span>INTERNAL_VOLUME);
        scan(context, MediaProvider<span class="built_in">.</span>EXTERNAL_VOLUME);

    } <span class="keyword">else</span> {
        <span class="keyword">if</span> (uri<span class="built_in">.</span>getScheme()<span class="built_in">.</span><span class="keyword">equals</span>(<span class="string">"file"</span>)) {
            <span class="comment">// handle intents related to external storage</span>
            <span class="comment">//uri = file:///storage/emulated/0/Sound_recorder/%E5%BD%95%E9%9F%B3_2015%E5%B9%B412%E6%9C%882%E6%97%A5_11%E7%82%B918%E5%88%8653%E7%A7%92.aac, </span>
            <span class="comment">//path = /storage/emulated/0/Sound_recorder/录音_2015年12月2日_11点18分53秒.aac</span>
            <span class="built_in">String</span> path = uri<span class="built_in">.</span>getPath();
            <span class="built_in">String</span> externalStoragePath = Environment<span class="built_in">.</span>getExternalStorageDirectory()<span class="built_in">.</span>getPath();<span class="comment">// /storage/emulated/0</span>
            <span class="built_in">String</span> legacyPath = Environment<span class="built_in">.</span>getLegacyExternalStorageDirectory()<span class="built_in">.</span>getPath();<span class="comment">// /sdcard</span>

            try {
                path = <span class="literal">new</span> File(path)<span class="built_in">.</span>getCanonicalPath();
            } catch (IOException e) {
                <span class="keyword">Log</span><span class="built_in">.</span>e(<span class="built_in">TAG</span>, <span class="string">"couldn't canonicalize "</span> + path);
                <span class="keyword">return</span>;
            }
            <span class="keyword">if</span> (path<span class="built_in">.</span>startsWith(legacyPath)) {
                path = externalStoragePath + path<span class="built_in">.</span>substring(legacyPath<span class="built_in">.</span>length());
            }

            <span class="keyword">Log</span><span class="built_in">.</span>d(<span class="built_in">TAG</span>, <span class="string">"action: "</span> + action + <span class="string">" path: "</span> + path);
            <span class="keyword">if</span> (Intent<span class="built_in">.</span>ACTION_MEDIA_MOUNTED<span class="built_in">.</span><span class="keyword">equals</span>(action)) {
                <span class="comment">//接收MEDIA_MOUNTED，扫描 外部存储 /storage/emulated/0</span>
                <span class="comment">// scan whenever any volume is mounted</span>
                scan(context, MediaProvider<span class="built_in">.</span>EXTERNAL_VOLUME);
            } <span class="keyword">else</span> <span class="keyword">if</span> (Intent<span class="built_in">.</span>ACTION_MEDIA_SCANNER_SCAN_FILE<span class="built_in">.</span><span class="keyword">equals</span>(action) <span class="subst">&amp;&amp;</span>
                    path != <span class="built_in">null</span> <span class="subst">&amp;&amp;</span> path<span class="built_in">.</span>startsWith(externalStoragePath + <span class="string">"/"</span>)) {
                <span class="comment">//外部应用 可以通过发送 ACTION_MEDIA_SCANNER_SCAN_FILE 让MediaScannerReceiver扫描 单个文件，这个文件必须位于SD卡上</span>
                scanFile(context, path);
            }
        }
    }
}
<span class="keyword">private</span> <span class="literal">void</span> scan(Context context, <span class="built_in">String</span> volume) {
    Bundle args = <span class="literal">new</span> Bundle();
    args<span class="built_in">.</span>putString(<span class="string">"volume"</span>, volume);
    <span class="comment">//启动 MediaScannerService</span>
    context<span class="built_in">.</span>startService(
            <span class="literal">new</span> Intent(context, MediaScannerService<span class="built_in">.</span>class)<span class="built_in">.</span>putExtras(args));
}    

<span class="keyword">private</span> <span class="literal">void</span> scanFile(Context context, <span class="built_in">String</span> path) {
    Bundle args = <span class="literal">new</span> Bundle();
    args<span class="built_in">.</span>putString(<span class="string">"filepath"</span>, path);
    <span class="comment">//启动 MediaScannerService</span>
    context<span class="built_in">.</span>startService(
            <span class="literal">new</span> Intent(context, MediaScannerService<span class="built_in">.</span>class)<span class="built_in">.</span>putExtras(args));
}   
</code></pre><p>MediaProvider.java</p>
<pre><code><span class="literal">static</span> <span class="keyword">final</span> <span class="built_in">String</span> INTERNAL_VOLUME = <span class="string">"internal"</span>;
<span class="literal">static</span> <span class="keyword">final</span> <span class="built_in">String</span> EXTERNAL_VOLUME = <span class="string">"external"</span>;
</code></pre><p>MediaScannerReceiver接收三种请求：</p>
<ul>
<li>ACTION_BOOT_COMPLETED：扫描内部 外部存储</li>
<li>ACTION_MEDIA_MOUNTED：扫描外部存储</li>
<li>ACTION_MEDIA_SCANNER_SCAN_FILE：扫描Sd卡上的一个文件，文件路径必须以Environment.getExternalStorageDirectory().getPath() 开头</li>
</ul>
<h2 id="2-MediaScannerService">2.MediaScannerService</h2><pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MediaScannerService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Service</span> <span class="title">implements</span> <span class="title">Runnable</span></span>
</code></pre><h3 id="2-1_onCreate">2.1 onCreate</h3><pre><code>    <span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span>
</span>{
    <span class="comment">//获得PowerManager，防止扫描过程中休眠</span>
    PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
    StorageManager storageManager = (StorageManager)getSystemService(Context.STORAGE_SERVICE);
    mExternalStoragePaths = storageManager.getVolumePaths();

    <span class="comment">// Start up the thread running the service.  Note that we create a</span>
    <span class="comment">// separate thread because the service normally runs in the process's</span>
    <span class="comment">// main thread, which we don't want to block.</span>
    Thread thr = <span class="keyword">new</span> Thread(<span class="keyword">null</span>, <span class="keyword">this</span>, <span class="string">"MediaScannerService"</span>);
    thr.start();<span class="comment">//创建一个工作线程，工作在MediaScannerService的run()中</span>
}

<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>
</span>{
    <span class="comment">//设置线程的优先级，调低优先级，避免MediaScannerService一直占用CPU，导致系统卡</span>
    <span class="comment">// reduce priority below other background threads to avoid interfering</span>
    <span class="comment">// with other services at boot time.</span>
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND +
            Process.THREAD_PRIORITY_LESS_FAVORABLE);
    Looper.prepare();

    mServiceLooper = Looper.myLooper();
    mServiceHandler = <span class="keyword">new</span> ServiceHandler();<span class="comment">//创建一个Handler</span>

    Looper.loop();
}
</code></pre><p>onCreate后，MediaScannerService创建一个 带消息处理机制 的工作线程，消息 如何传递到 这个线程呢？</p>
<h2 id="2-2_onStartCommand">2.2 onStartCommand</h2><pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span>
</span>{
    <span class="comment">//等待mServiceHandler被创建</span>
    <span class="keyword">while</span> (mServiceHandler == <span class="keyword">null</span>) {
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
            <span class="keyword">try</span> {
                wait(<span class="number">100</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
            }
        }
    }

    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) {
        Log.e(TAG, <span class="string">"Intent is null in onStartCommand: "</span>,
            <span class="keyword">new</span> NullPointerException());
        <span class="keyword">return</span> Service.START_NOT_STICKY;
    }

    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = startId;
    msg.obj = intent.getExtras();
    mServiceHandler.sendMessage(msg);<span class="comment">//发消息，最终由工作线程处理</span>

    <span class="comment">// Try again later if we are killed before we can finish scanning.</span>
    <span class="keyword">return</span> Service.START_REDELIVER_INTENT;
}
</code></pre><p>onStartCommand将 扫描请求信息 投递到 工作线程中 去处理。</p>
<h2 id="2-3处理扫描请求">2.3处理扫描请求</h2><pre><code><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span>
</span>{
    <span class="annotation">@Override</span>
    public void handleMessage(<span class="type">Message</span> msg)
    {
        <span class="type">Bundle</span> arguments = (<span class="type">Bundle</span>) msg.obj;
        <span class="type">String</span> filePath = arguments.getString(<span class="string">"filepath"</span>);

        <span class="keyword">try</span> {
            ……
            } <span class="keyword">else</span> {
                <span class="type">String</span> volume = arguments.getString(<span class="string">"volume"</span>);
                <span class="type">String</span>[] directories = <span class="literal">null</span>;

                <span class="keyword">if</span> (<span class="type">MediaProvider</span>.<span class="type">INTERNAL_VOLUME</span>.equals(volume)) {
                    <span class="comment">//扫描内部存储，Environment.getRootDirectory()：/system ，Environment.getOemDirectory() ： /oem </span>
                    <span class="comment">// scan internal media storage</span>
                    directories = <span class="keyword">new</span> <span class="type">String</span>[] {
                            <span class="type">Environment</span>.getRootDirectory() + <span class="string">"/media"</span>,
                            <span class="type">Environment</span>.getOemDirectory() + <span class="string">"/media"</span>,
                    };
                }
                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">MediaProvider</span>.<span class="type">EXTERNAL_VOLUME</span>.equals(volume)) {
                    <span class="comment">// scan external storage volumes</span>
                    directories = mExternalStoragePaths;<span class="comment">// [/storage/emulated/0]</span>
                }

                <span class="keyword">if</span> (directories != <span class="literal">null</span>) {
                    <span class="keyword">if</span> (<span class="literal">false</span>) <span class="type">Log</span>.d(<span class="type">TAG</span>, <span class="string">"start scanning volume "</span> + volume + <span class="string">": "</span>
                            + <span class="type">Arrays</span>.toString(directories));
                    <span class="comment">//调用scan函数扫描文件夹，可以一次设置多个目标文件夹</span>
                    scan(directories, volume);
                    <span class="keyword">if</span> (<span class="literal">false</span>) <span class="type">Log</span>.d(<span class="type">TAG</span>, <span class="string">"done scanning volume "</span> + volume);
                }
            }
        } <span class="keyword">catch</span> (<span class="type">Exception</span> e) {
            <span class="type">Log</span>.e(<span class="type">TAG</span>, <span class="string">"Exception in handleMessage"</span>, e);
        }

        stopSelf(msg.arg1);
    }
};
</code></pre><h2 id="2-4_MediaScannerService的scan函数">2.4 MediaScannerService的scan函数</h2><pre><code>private <span class="keyword">void</span> scan(<span class="built_in">String</span>[] directories, <span class="built_in">String</span> volumeName) {
    <span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">"file://"</span> + directories[<span class="number">0</span>]);
    <span class="comment">// don't sleep while scanning</span>
    mWakeLock.acquire();

    <span class="keyword">try</span> {
        ContentValues values = <span class="keyword">new</span> ContentValues();
        values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
        <span class="comment">//MediaScannerService通过insert这个特殊的Uri让MediaProvider做一些准备工作</span>
        <span class="comment">//MediaStore.getMediaScannerUri(): content://media/none/media_scanner</span>
        <span class="built_in">Uri</span> scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

        <span class="comment">//发ACTION_MEDIA_SCANNER_STARTED广播</span>
        sendBroadcast(<span class="keyword">new</span> Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

        <span class="keyword">try</span> {
            <span class="keyword">if</span> (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
                <span class="comment">//打开数据库</span>
                openDatabase(volumeName);
            }

            <span class="comment">//创建MediaScanner，调用scanDirectories扫描目标文件夹</span>
            MediaScanner scanner = createMediaScanner();
            scanner.scanDirectories(directories, volumeName);
        } <span class="keyword">catch</span> (Exception e) {
            Log.e(TAG, <span class="string">"exception in MediaScanner.scan()"</span>, e);
        }
        <span class="comment">//通过 特殊Uri 让MediaProvider 做一些清理工作</span>
        getContentResolver().delete(scanUri, <span class="keyword">null</span>, <span class="keyword">null</span>);

    } <span class="keyword">finally</span> {
        <span class="comment">//发送ACTION_MEDIA_SCANNER_FINISHED广播</span>
        sendBroadcast(<span class="keyword">new</span> Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
        mWakeLock.release();
    }
}
<span class="comment">//openDatabase()通过insert这个特殊的Uri 让MediaProvider打开数据库</span>
private <span class="keyword">void</span> openDatabase(<span class="built_in">String</span> volumeName) {
    <span class="keyword">try</span> {
        ContentValues values = <span class="keyword">new</span> ContentValues();
        values.put(<span class="string">"name"</span>, volumeName);
        getContentResolver().insert(<span class="built_in">Uri</span>.parse(<span class="string">"content://media/"</span>), values);
    } <span class="keyword">catch</span> (IllegalArgumentException ex) {
        Log.w(TAG, <span class="string">"failed to open media database"</span>);
    }         
}
</code></pre><p>上边代码中，比较复杂的是 MediaScannerService和MediaProvider交互。除了后文的正常数据库操作外，MediaScannerService还经常会使用一些特殊的Uri来做数据库操作，而MediaProvider针对Uri会做一些特殊处理，如打开数据库文件等。</p>
<pre><code><span class="keyword">private</span> MediaScanner createMediaScanner() {
    MediaScanner scanner = <span class="literal">new</span> MediaScanner(this);
    <span class="comment">//获取当前系统使用的区域信息，扫描的时候 将 媒体文件信息 转换成 当前系统的语言</span>
    <span class="built_in">Locale</span> <span class="built_in">locale</span> = getResources()<span class="built_in">.</span>getConfiguration()<span class="built_in">.</span><span class="built_in">locale</span>;
    <span class="keyword">if</span> (<span class="built_in">locale</span> != <span class="built_in">null</span>) {
        <span class="built_in">String</span> language = <span class="built_in">locale</span><span class="built_in">.</span>getLanguage();
        <span class="built_in">String</span> country = <span class="built_in">locale</span><span class="built_in">.</span>getCountry();
        <span class="built_in">String</span> localeString = <span class="built_in">null</span>;
        <span class="keyword">if</span> (language != <span class="built_in">null</span>) {
            <span class="keyword">if</span> (country != <span class="built_in">null</span>) {
                <span class="comment">//为扫描器 设置当前系统使用的 国家和语言</span>
                scanner<span class="built_in">.</span>setLocale(language + <span class="string">"_"</span> + country);
            } <span class="keyword">else</span> {
                scanner<span class="built_in">.</span>setLocale(language);
            }
        }    
    }

    <span class="keyword">return</span> scanner;
}
</code></pre><h2 id="2-3媒体扫描工作总结">2.3媒体扫描工作总结</h2><p>MediaScannerReceiver和MediaScannerService交互，流程：</p>
<ul>
<li>MediaScannerReceiver 接收 外部发来 的扫描请求，通过startService启动MediaScannerService处理</li>
<li>MediaScannerService的 主线程接收 MediaScannerReceiver收到的请求，然后 投递给 工作线程去处理</li>
<li>工作线程做一些 前期处理工作（例如 向系统发 扫描开始的 广播），创建MediaScanner来处理扫描目标</li>
<li>MediaScanner扫描完成后，工作线程 做后期处理，然后向系统 发扫描完毕的广播</li>
</ul>
<h1 id="3-MediaScanner分析">3.MediaScanner分析</h1><p>MediaScanner工作原理，跨 Java层、JNI层 Native层。</p>
<h2 id="3-1_Java层">3.1 Java层</h2><h3 id="3-1-1_创建MediaScanner">3.1.1 创建MediaScanner</h3><pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MediaScanner</span></span>
{
    static {
            <span class="constant">System</span>.loadLibrary(<span class="string">"media_jni"</span>);<span class="regexp">//</span>加载system/<span class="class"><span class="keyword">lib</span>/<span class="title">libmedia_jni</span>.<span class="title">so</span></span>
        native_init();
    }
    ……
    public <span class="constant">MediaScanner</span>(<span class="constant">Context</span> c) {
        native_setup();<span class="regexp">//</span>调用<span class="constant">JNI</span>层 做一些初始化 工作
        ……
    }
}
</code></pre><h3 id="3-1-2_scanDirectories分析">3.1.2 scanDirectories分析</h3><pre><code><span class="comment">/** whether to use bulk inserts or individual inserts for each item */</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">boolean</span> ENABLE_BULK_INSERTS = <span class="keyword">true</span>;

<span class="keyword">public</span> <span class="keyword">void</span> scanDirectories(<span class="keyword">String</span>[] directories, <span class="keyword">String</span> volumeName) {
    <span class="keyword">try</span> {
        <span class="keyword">long</span> start = System.currentTimeMillis();
        initialize(volumeName);<span class="comment">//（1）初始化</span>
        prescan(<span class="keyword">null</span>, <span class="keyword">true</span>);<span class="comment">//（2）扫描前的预处理</span>
        <span class="keyword">long</span> prescan = System.currentTimeMillis();

        <span class="keyword">if</span> (ENABLE_BULK_INSERTS) {
            <span class="comment">//MediaInserter: A MediaScanner helper class which enables us to do lazy insertion on the given provider. This class manages buffers internally and flushes when they are full. Note that you should call flushAll() after using this class.</span>
            <span class="comment">// create MediaInserter for bulk inserts</span>
            mMediaInserter = <span class="keyword">new</span> MediaInserter(mMediaProvider, mPackageName, <span class="number">500</span>);
        }

        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; directories.length; i++) {
            <span class="comment">//processDirectory是一个native函数，调用它 扫描目标文件夹</span>
            <span class="comment">//mClient是MyMediaScannerClient类型，派生自MediaScannerClient，其作用后面再分析</span>
            processDirectory(directories[i], mClient);
        }

        <span class="keyword">if</span> (ENABLE_BULK_INSERTS) {
            <span class="comment">// flush remaining inserts</span>
            mMediaInserter.flushAll();
            mMediaInserter = <span class="keyword">null</span>;
        }

        <span class="keyword">long</span> scan = System.currentTimeMillis();
        postscan(directories);<span class="comment">//(4)扫描后 处理</span>
        <span class="keyword">long</span> end = System.currentTimeMillis();

        <span class="keyword">if</span> (<span class="keyword">false</span>) {
            Log.d(TAG, <span class="string">" prescan time: "</span> + (prescan - start) + <span class="string">"ms\n"</span>);
            Log.d(TAG, <span class="string">"    scan time: "</span> + (scan - prescan) + <span class="string">"ms\n"</span>);
            Log.d(TAG, <span class="string">"postscan time: "</span> + (end - scan) + <span class="string">"ms\n"</span>);
            Log.d(TAG, <span class="string">"   total time: "</span> + (end - start) + <span class="string">"ms\n"</span>);
        }
    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// this might happen if the SD card is removed while the media scanner is running</span>
        Log.e(TAG, <span class="string">"SQLException in MediaScanner.scan()"</span>, e);
    } <span class="keyword">catch</span> (UnsupportedOperationException e) {
        <span class="comment">// this might happen if the SD card is removed while the media scanner is running</span>
        Log.e(TAG, <span class="string">"UnsupportedOperationException in MediaScanner.scan()"</span>, e);
    } <span class="keyword">catch</span> (RemoteException e) {
        Log.e(TAG, <span class="string">"RemoteException in MediaScanner.scan()"</span>, e);
    } <span class="keyword">finally</span> {
        releaseResources();
    }
}
</code></pre><p><strong> （1）initialize分析 </strong><br>initialize主要是 初始化一些Uri<br>扫描时 需要把文件的信息 插入到媒体库中，媒体库中 针对 Video、Audio、Image文件有对应的表，表的地址由Uri表示。</p>
<pre><code><span class="keyword">private</span> <span class="literal">void</span> initialize(<span class="built_in">String</span> volumeName) {
    mMediaProvider = mContext<span class="built_in">.</span>getContentResolver()<span class="built_in">.</span>acquireProvider(<span class="string">"media"</span>);

    mAudioUri = Audio<span class="built_in">.</span>Media<span class="built_in">.</span>getContentUri(volumeName);<span class="comment">//音频表的地址，对应audio_meta表</span>
    mVideoUri = Video<span class="built_in">.</span>Media<span class="built_in">.</span>getContentUri(volumeName);<span class="comment">//视频表地址，对应video表</span>
    mImagesUri = Images<span class="built_in">.</span>Media<span class="built_in">.</span>getContentUri(volumeName);<span class="comment">//图片表地址，对应images表</span>
    mThumbsUri = Images<span class="built_in">.</span>Thumbnails<span class="built_in">.</span>getContentUri(volumeName);<span class="comment">//缩略图地址，对应thumbnails表</span>
    mFilesUri = Files<span class="built_in">.</span>getContentUri(volumeName);<span class="comment">//所有文件的地址，对应files表</span>
    mFilesUriNoNotify = mFilesUri<span class="built_in">.</span>buildUpon()<span class="built_in">.</span>appendQueryParameter(<span class="string">"nonotify"</span>, <span class="string">"1"</span>)<span class="built_in">.</span>build();

    <span class="keyword">if</span> (<span class="subst">!</span>volumeName<span class="built_in">.</span><span class="keyword">equals</span>(<span class="string">"internal"</span>)) {
        <span class="comment">//如果扫描的是 外部存储，支持 播放列表、音乐的流派等内容</span>
        <span class="comment">// we only support playlists on external media</span>
        mProcessPlaylists = <span class="literal">true</span>;
        mProcessGenres = <span class="literal">true</span>;
        mPlaylistsUri = Playlists<span class="built_in">.</span>getContentUri(volumeName);

        mCaseInsensitivePaths = <span class="literal">true</span>;<span class="comment">//Sd卡存储区域一般使用FAT文件系统，文件名与大小写无关</span>
    }
}
</code></pre><p><strong> （2）prescan分析 </strong><br>媒体扫描的问题：假设扫描之前SD卡有100个媒体文件，数据库中有100个关于文件的记录，因某种原因 删除了50个媒体文件，那么 数据库什么时候更新呢？</p>
<p>prescan函数的主要作用就是 在扫描之前 把数据库中 和文件关联的信息 取出并保存，这些信息主要是 媒体文件的路径 所属表的Uri。上边的例子，prescan会从数据库中 取出这100个文件 的文件信息。</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> prescan(<span class="keyword">String</span> filePath, <span class="built_in">boolean</span> prescanFiles) <span class="keyword">throws</span> RemoteException {
    Cursor c = <span class="keyword">null</span>;
    <span class="keyword">String</span> where = <span class="keyword">null</span>;
    <span class="keyword">String</span>[] selectionArgs = <span class="keyword">null</span>;

    <span class="comment">//保存从数据库中获取的文件信息</span>
    <span class="keyword">if</span> (mPlayLists == <span class="keyword">null</span>) {
        mPlayLists = <span class="keyword">new</span> ArrayList&lt;FileEntry&gt;();
    } <span class="keyword">else</span> {
        mPlayLists.<span class="built_in">clear</span>();
    }

    <span class="keyword">if</span> (filePath != <span class="keyword">null</span>) {
        <span class="comment">//查询file信息</span>
        <span class="comment">// query for only one file</span>
        where = MediaStore.Files.FileColumns._ID + <span class="string">"&gt;?"</span> +
            <span class="string">" AND "</span> + Files.FileColumns.DATA + <span class="string">"=?"</span>;
        selectionArgs = <span class="keyword">new</span> <span class="keyword">String</span>[] { <span class="string">""</span>, filePath };
    } <span class="keyword">else</span> {
        where = MediaStore.Files.FileColumns._ID + <span class="string">"&gt;?"</span>;
        selectionArgs = <span class="keyword">new</span> <span class="keyword">String</span>[] { <span class="string">""</span> };
    }

    <span class="comment">// Tell the provider to not delete the file.</span>
    <span class="comment">// If the file is truly gone the delete is unnecessary, and we want to avoid</span>
    <span class="comment">// accidentally deleting files that are really there (this may happen if the</span>
    <span class="comment">// filesystem is mounted and unmounted while the scanner is running).</span>
    Uri.Builder builder = mFilesUri.buildUpon();
    builder.appendQueryParameter(MediaStore.PARAM_DELETE_DATA, <span class="string">"false"</span>);
    MediaBulkDeleter deleter = <span class="keyword">new</span> MediaBulkDeleter(mMediaProvider, mPackageName,
            builder.build());

    <span class="comment">// Build the list of files from the content provider</span>
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (prescanFiles) {
            <span class="comment">// First read existing files from the files table.</span>
            <span class="comment">// Because we'll be deleting entries for missing files as we go,</span>
            <span class="comment">// we need to query the database in small batches, to avoid problems</span>
            <span class="comment">// with CursorWindow positioning.</span>
            <span class="keyword">long</span> lastId = Long.MIN_VALUE;
            Uri limitUri = mFilesUri.buildUpon().appendQueryParameter(<span class="string">"limit"</span>, <span class="string">"1000"</span>).build();
            mWasEmptyPriorToScan = <span class="keyword">true</span>;

            <span class="keyword">while</span> (<span class="keyword">true</span>) {
                selectionArgs[<span class="number">0</span>] = <span class="string">""</span> + lastId;
                <span class="keyword">if</span> (c != <span class="keyword">null</span>) {
                    c.close();
                    c = <span class="keyword">null</span>;
                }
                <span class="comment">//查询files信息</span>
                c = mMediaProvider.query(mPackageName, limitUri, FILES_PRESCAN_PROJECTION,
                        where, selectionArgs, MediaStore.Files.FileColumns._ID, <span class="keyword">null</span>);
                <span class="keyword">if</span> (c == <span class="keyword">null</span>) {
                    <span class="keyword">break</span>;
                }

                <span class="built_in">int</span> num = c.getCount();

                <span class="keyword">if</span> (num == <span class="number">0</span>) {
                    <span class="keyword">break</span>;
                }
                mWasEmptyPriorToScan = <span class="keyword">false</span>;
                <span class="keyword">while</span> (c.moveToNext()) {
                    <span class="keyword">long</span> rowId = c.getLong(FILES_PRESCAN_ID_COLUMN_INDEX);
                    <span class="keyword">String</span> path = c.getString(FILES_PRESCAN_PATH_COLUMN_INDEX);<span class="comment">//查询文件路径</span>
                    <span class="built_in">int</span> format = c.getInt(FILES_PRESCAN_FORMAT_COLUMN_INDEX);
                    <span class="keyword">long</span> lastModified = c.getLong(FILES_PRESCAN_DATE_MODIFIED_COLUMN_INDEX);
                    lastId = rowId;

                    <span class="comment">// Only consider entries with absolute path names.</span>
                    <span class="comment">// This allows storing URIs in the database without the</span>
                    <span class="comment">// media scanner removing them.</span>
                    <span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">"/"</span>)) {
                        <span class="built_in">boolean</span> exists = <span class="keyword">false</span>;
                        <span class="keyword">try</span> {
                            exists = Os.access(path, android.system.OsConstants.F_OK);
                        } <span class="keyword">catch</span> (ErrnoException e1) {
                        }
                        <span class="keyword">if</span> (!exists &amp;&amp; !MtpConstants.isAbstractObject(format)) {
                            <span class="comment">// do not delete missing playlists, since they may have been</span>
                            <span class="comment">// modified by the user.</span>
                            <span class="comment">// The user can delete them in the media player instead.</span>
                            <span class="comment">// instead, clear the path and lastModified fields in the row</span>
                            MediaFile.MediaFileType mediaFileType = MediaFile.getFileType(path);
                            <span class="built_in">int</span> fileType = (mediaFileType == <span class="keyword">null</span> ? <span class="number">0</span> : mediaFileType.fileType);

                            <span class="keyword">if</span> (!MediaFile.isPlayListFileType(fileType)) {
                                deleter.delete(rowId);
                                <span class="keyword">if</span> (path.toLowerCase(Locale.US).endsWith(<span class="string">"/.nomedia"</span>)) {
                                    deleter.flush();
                                    <span class="keyword">String</span> parent = <span class="keyword">new</span> File(path).getParent();
                                    mMediaProvider.call(mPackageName, MediaStore.UNHIDE_CALL,
                                            parent, <span class="keyword">null</span>);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    <span class="keyword">finally</span> {
        <span class="keyword">if</span> (c != <span class="keyword">null</span>) {
            c.close();
        }
        deleter.flush();
    }

    <span class="comment">// compute original size of images</span>
    mOriginalCount = <span class="number">0</span>;
    c = mMediaProvider.query(mPackageName, mImagesUri, ID_PROJECTION, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
    <span class="keyword">if</span> (c != <span class="keyword">null</span>) {
        mOriginalCount = c.getCount();
        c.close();
    }
}
</code></pre><p><strong> （3）processDirectory 和 postscan分析 </strong></p>
<pre><code><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">processDirectory</span><span class="params">(String path, MediaScannerClient client)</span></span>;


<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">postscan</span><span class="params">(String[] directories)</span> <span class="keyword">throws</span> RemoteException </span>{

    <span class="comment">// handle playlists last, after we know what media files are on the storage.</span>
    <span class="keyword">if</span> (mProcessPlaylists) {
        processPlayLists();
    }

    <span class="keyword">if</span> (mOriginalCount == <span class="number">0</span> &amp;&amp; mImagesUri.equals(Images.Media.getContentUri(<span class="string">"external"</span>)))
        pruneDeadThumbnailFiles();

    <span class="comment">// allow GC to clean up</span>
    mPlayLists = <span class="keyword">null</span>;
    mMediaProvider = <span class="keyword">null</span>;
}
</code></pre><p>processDirectory是一个native函数，JNI层实现。processDirectory扫描SD卡</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">processPlayLists</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>{
    Iterator&lt;FileEntry&gt; iterator = mPlayLists.iterator();
    Cursor fileList = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        <span class="comment">// use the files uri and projection because we need the format column,</span>
        <span class="comment">// but restrict the query to just audio files</span>
        fileList = mMediaProvider.query(mPackageName, mFilesUri, FILES_PRESCAN_PROJECTION,
                <span class="string">"media_type=2"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
        <span class="keyword">while</span> (iterator.hasNext()) {
            FileEntry entry = iterator.next();
            <span class="comment">// only process playlist files if they are new or have been modified since the last scan</span>
            <span class="keyword">if</span> (entry.mLastModifiedChanged) {
                processPlayList(entry, fileList);
            }
        }
    } <span class="keyword">catch</span> (RemoteException e1) {
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span> (fileList != <span class="keyword">null</span>) {
            fileList.close();
        }
    }
}


<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">processPlayList</span><span class="params">(FileEntry entry, Cursor fileList)</span> <span class="keyword">throws</span> RemoteException </span>{
    String path = entry.mPath;
    ContentValues values = <span class="keyword">new</span> ContentValues();
    <span class="keyword">int</span> lastSlash = path.lastIndexOf(<span class="string">'/'</span>);
    <span class="keyword">if</span> (lastSlash &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"bad path "</span> + path);
    Uri uri, membersUri;
    <span class="keyword">long</span> rowId = entry.mRowId;

    <span class="comment">// make sure we have a name</span>
    String name = values.getAsString(MediaStore.Audio.Playlists.NAME);
    <span class="keyword">if</span> (name == <span class="keyword">null</span>) {
        name = values.getAsString(MediaStore.MediaColumns.TITLE);
        <span class="keyword">if</span> (name == <span class="keyword">null</span>) {
            <span class="comment">// extract name from file name</span>
            <span class="keyword">int</span> lastDot = path.lastIndexOf(<span class="string">'.'</span>);
            name = (lastDot &lt; <span class="number">0</span> ? path.substring(lastSlash + <span class="number">1</span>)
                    : path.substring(lastSlash + 1, lastDot));
        }
    }

    values.put(MediaStore.Audio.Playlists.NAME, name);
    values.put(MediaStore.Audio.Playlists.DATE_MODIFIED, entry.mLastModified);

    <span class="keyword">if</span> (rowId == <span class="number">0</span>) {
        values.put(MediaStore.Audio.Playlists.DATA, path);
        uri = mMediaProvider.insert(mPackageName, mPlaylistsUri, values);
        rowId = ContentUris.parseId(uri);
        membersUri = Uri.withAppendedPath(uri, Playlists.Members.CONTENT_DIRECTORY);
    } <span class="keyword">else</span> {
        uri = ContentUris.withAppendedId(mPlaylistsUri, rowId);
        mMediaProvider.update(mPackageName, uri, values, <span class="keyword">null</span>, <span class="keyword">null</span>);

        <span class="comment">// delete members of existing playlist</span>
        membersUri = Uri.withAppendedPath(uri, Playlists.Members.CONTENT_DIRECTORY);
        mMediaProvider.delete(mPackageName, membersUri, <span class="keyword">null</span>, <span class="keyword">null</span>);
    }

    String playListDirectory = path.substring(<span class="number">0</span>, lastSlash + <span class="number">1</span>);
    MediaFile.MediaFileType mediaFileType = MediaFile.getFileType(path);
    <span class="keyword">int</span> fileType = (mediaFileType == <span class="keyword">null</span> ? <span class="number">0</span> : mediaFileType.fileType);

    <span class="keyword">if</span> (fileType == MediaFile.FILE_TYPE_M3U) {
        processM3uPlayList(path, playListDirectory, membersUri, values, fileList);
    } <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(fileType == MediaFile.FILE_TYPE_PLS)</span> </span>{
        processPlsPlayList(path, playListDirectory, membersUri, values, fileList);
    } <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(fileType == MediaFile.FILE_TYPE_WPL)</span> </span>{
        processWplPlayList(path, playListDirectory, membersUri, values, fileList);
    }
}
</code></pre><h2 id="3-2_JNI层">3.2 JNI层</h2><h3 id="3-2-1_native_init">3.2.1 native_init</h3><p>MediaScanner的static块中调用</p>
<pre><code><span class="comment">// This function gets a field ID, which in turn causes class initialization.</span>
<span class="comment">// It is called from a static block in MediaScanner, which won't run until the</span>
<span class="comment">// first time an instance of this class is used.</span>
<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>
<span class="title">android_media_MediaScanner_native_init</span><span class="params">(JNIEnv *env)</span>
</span>{
    ALOGV(<span class="string">"native_init"</span>);
    jclass clazz = env-&gt;FindClass(kClassMediaScanner);
    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) {
           <span class="keyword">return</span>;
    }

    <span class="comment">//取得Java层MediaScanner类的mNativeContext信息，Native对象的指针保存到Java层MediaScanner对象的mNativeContext中</span>
    fields.context = env-&gt;GetFieldID(clazz, <span class="string">"mNativeContext"</span>, <span class="string">"J"</span>);
    <span class="keyword">if</span> (fields.context == <span class="literal">NULL</span>) {
        <span class="keyword">return</span>;
    }
}
</code></pre><h3 id="3-2-2_native_setup">3.2.2 native_setup</h3><pre><code>static void
android_media_MediaScanner_native_setup<span class="list">(<span class="keyword">JNIEnv</span> <span class="variable">*env, jobject thiz)
{
    ALOGV("native_setup");
    MediaScanner *</span>mp = new StagefrightMediaScanner<span class="comment">;//创建Native层的MediaScanner对象</span>

    if <span class="list">(<span class="keyword">mp</span> == NULL)</span> {
        jniThrowException<span class="list">(<span class="keyword">env</span>, kRunTimeException, <span class="string">"Out of memory"</span>)</span><span class="comment">;</span>
        return<span class="comment">;</span>
    }

    env-&gt;SetLongField<span class="list">(<span class="keyword">thiz</span>, fields.context, <span class="list">(<span class="keyword">jlong</span>)</span>mp)</span><span class="comment">;</span>
}</span>
</code></pre><h3 id="3-2-3_processDirectory">3.2.3 processDirectory</h3><pre><code><span class="keyword">static</span> <span class="type">void</span>
android_media_MediaScanner_processDirectory(
        <span class="type">JNIEnv</span> *env, jobject thiz, jstring path, jobject client)
{
    <span class="type">ALOGV</span>(<span class="string">"processDirectory"</span>);
    <span class="type">MediaScanner</span> *mp = getNativeScanner_l(env, thiz);
    <span class="keyword">if</span> (mp == <span class="type">NULL</span>) {
        jniThrowException(env, kRunTimeException, <span class="string">"No scanner available"</span>);
        <span class="keyword">return</span>;
    }

    <span class="keyword">if</span> (path == <span class="type">NULL</span>) {
        jniThrowException(env, kIllegalArgumentException, <span class="type">NULL</span>);
        <span class="keyword">return</span>;
    }

    <span class="keyword">const</span> <span class="type">char</span> *pathStr = env-&gt;<span class="type">GetStringUTFChars</span>(path, <span class="type">NULL</span>);
    <span class="keyword">if</span> (pathStr == <span class="type">NULL</span>) {  // <span class="type">Out</span> <span class="keyword">of</span> memory
        <span class="keyword">return</span>;
    }

    //构造<span class="type">Native</span>层的<span class="type">MyMediaScannerClient</span>，并使用<span class="type">Java</span>层的<span class="type">Client</span>对象做参数
    <span class="type">MyMediaScannerClient</span> myClient(env, client);
    <span class="type">MediaScanResult</span> <span class="literal">result</span> = mp-&gt;processDirectory(pathStr, myClient);//调用<span class="type">Native</span>层的<span class="type">MediaScanner</span>扫描文件夹，并把<span class="type">Native</span>的<span class="type">MyMediaScannerClient</span>传进去
    <span class="keyword">if</span> (<span class="literal">result</span> == <span class="type">MEDIA_SCAN_RESULT_ERROR</span>) {
        <span class="type">ALOGE</span>(<span class="string">"An error occurred while scanning directory '%s'."</span>, pathStr);
    }
    env-&gt;<span class="type">ReleaseStringUTFChars</span>(path, pathStr);
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/framework/">framework</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据结构3-树-上-——3-1-树与树的表示" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/02/数据结构3-树-上-——3-1-树与树的表示/" class="article-date">
  	<time datetime="2015-12-02T02:01:52.000Z" itemprop="datePublished">2015-12-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/02/数据结构3-树-上-——3-1-树与树的表示/">数据结构3-树(上)——3-1-树与树的表示</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="3-1_树与树的表示">3.1 树与树的表示</h1><h2 id="3-1-1什么是树">3.1.1什么是树</h2><p>客观世界中 许多事物 存在的 层次关系</p>
<ul>
<li>家谱</li>
<li>社会组织结构</li>
<li>图书信息管理</li>
</ul>
<p>分层次组织 在管理上 具有更高的效率。</p>
<h2 id="查找">查找</h2><p>查找： 根据 关键字K，从 集合R中 找出与K相同的记录</p>
<ul>
<li>静态查找：集合中 记录是固定的<ul>
<li>没有插入和删除操作，只有查找</li>
<li>举例：查字典</li>
</ul>
</li>
<li>动态查找： 集合中 记录是动态变化的<ul>
<li>除查找，还可以 插入和删除</li>
</ul>
</li>
</ul>
<h2 id="静态查找">静态查找</h2><h3 id="方法1：顺序查找">方法1：顺序查找</h3><pre><code><span class="keyword">int</span> SequentialSearch(StaticTable *Tbl, ElementType K){
    <span class="comment">//在表Tbl[1]-Tbl[n]中查找关键字为K的元素</span>
    <span class="keyword">int</span> i;
    Tbl-&gt;Element[<span class="number">0</span>] = K;<span class="comment">//建立哨兵</span>
    <span class="keyword">for</span>(i = Tbl-&gt;Length; Tbl-&gt;Element[i] != K; i--);
    <span class="keyword">return</span> i;<span class="comment">//找不到返回0</span>
}
</code></pre><p>//数据从1开始存储，时间复杂度O(n)</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/d5b1cc1c621830d978ae1b046cc820a0ec0bde80/201512/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.PNG" alt="顺序查找"></p>
<p><strong> 顺序查找的另一种实现：不用哨兵 </strong></p>
<pre><code><span class="built_in">int</span> SequentailSearch(StaticTable *Tbl, ElementType K){
    <span class="built_in">int</span> i<span class="comment">;</span>
    <span class="keyword">for</span>(i = Tbl-&gt;Length<span class="comment">; i&gt;0 &amp;&amp; Tbl-&gt;Element[i]!=K; i--);</span>
    <span class="keyword">return</span> i<span class="comment">;</span>
} 
</code></pre><h2 id="3-1-2_方法2：二分查找">3.1.2 方法2：二分查找</h2><p>假设n个数据元素时有序的：<br>    K1 &lt; K2 &lt; … &lt; Kn<br>并且 连续存放（数组），可以进行二分查找。</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/481c80d2db16be5cf93e1eb25728031b295736b3/201512/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%BE%E4%BE%8B.PNG" alt="二分查找举例"></p>
<h2 id="3-1-3_二分查找_代码实现">3.1.3 二分查找 代码实现</h2><pre><code>int <span class="type">BinarySearch</span>(<span class="type">StaticTable</span> *<span class="type">Tbl</span>, <span class="type">ElementType</span> <span class="type">K</span>){
    <span class="comment">//在表Tbl中查找K</span>
    int <span class="keyword">left</span>, <span class="keyword">right</span>, mid, <span class="type">NoFound</span> = -<span class="number">1</span>;

    <span class="keyword">left</span> = <span class="number">1</span>;<span class="comment">//初始左边界</span>
    <span class="keyword">right</span> = <span class="type">Tbl</span>-&gt;<span class="type">Length</span>;<span class="comment">//初始右边界</span>
    <span class="keyword">while</span>(<span class="keyword">left</span> &lt;= <span class="keyword">right</span>){
        mid = (<span class="keyword">left</span> + <span class="keyword">right</span>) / <span class="number">2</span>;<span class="comment">//计算中间坐标</span>
        <span class="keyword">if</span>(<span class="type">K</span> &lt; <span class="type">Tbl</span>-&gt;<span class="type">Element</span>[mid]){
            <span class="keyword">right</span> = mid - <span class="number">1</span>;<span class="comment">//调整右边界</span>
        } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">K</span> &gt; <span class="type">Tbl</span>-&gt;<span class="type">Element</span>[mid]){
            <span class="keyword">left</span> = mid + <span class="number">1</span>;<span class="comment">//调整左边界</span>
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> mid;
        }
    }
    <span class="keyword">return</span> <span class="type">NotFound</span>;<span class="comment">//查找不成功，返回-1</span>
}
</code></pre><p>二分查找的 时间复杂度O(logN)</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/b6a841cd9f31188ed06fc23784503b1b1295673c/201512/%E5%88%A4%E5%AE%9A%E6%A0%91.PNG" alt="判定树"></p>
<h2 id="3-1-4_树的定义">3.1.4 树的定义</h2><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/9092a46a668c1b08c73485b36ec8387f69408e80/201512/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.PNG" alt="树的定义"></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/fb3108289afb901f102b5a04bbf23625becb91a7/201512/%E6%A0%91%E4%B8%8E%E9%9D%9E%E6%A0%91.PNG" alt="树与非树"></p>
<h3 id="树的术语">树的术语</h3><ul>
<li>1.结点的度（Degree）：结点的子树个数</li>
<li>2.树的度：树的所有结点中 最大的度数</li>
<li>3.叶结点（Leaf）：度为0 的点，没有子树 的点</li>
<li>4.父结点（Parent）：有子树的结点 是其子树 的根结点 的父结点</li>
<li>5.子结点（Child）：若A结点是B结点的父结点，则称 B结点 是A结点 的子结点；子结点 也称 孩子结点</li>
<li>6.兄弟结点（Sibling）：具有 同一父结点 的各结点 彼此是 兄弟结点。</li>
<li>7.路径和 路径长度：从 结点n1到nk的路径 为 一个结点序列n1，n2，…，nk， ni是ni+1的父结点。路径 所包含的个数 为 路径长度</li>
<li>8.祖先结点（Ancestor）：沿 树根 到某一结点 路径上 的所以结点 都是 这个结点 的祖先结点</li>
<li>9.子孙结点（Descendant）：某一结点 的子树 中的 所有结点 是这个结点的子孙</li>
<li>10.结点的层次（Level）：规定 根结点在1层，其他 任一结点的层数 是其 父结点 的层数+1</li>
<li>11.树的深度（Depth）：树中所有结点中 的最大层次 是这棵树的 深度。</li>
</ul>
<h2 id="3-1-5_树的表示">3.1.5 树的表示</h2><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/90438b87d183998de2ce8be0e50a14382013674e/201512/%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA1.PNG" alt="树的表示1"></p>
<p><strong> 方式1：数组 </strong><br>数组 表示不了 谁是谁的父结点</p>
<p><strong> 方式二：链表 </strong></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/dc9e459ca97f628e6c57a33a48604119a8ba69ee/201512/%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA-%E9%93%BE%E8%A1%A8.PNG" alt="树的表示"></p>
<p>A有3个指针，B有2个指针，C有3个指针。<br>每个元素设置几个指针？都设置3个，空的指针个数很多，浪费资源。</p>
<p><strong> 方式三：儿子-兄弟表示法 </strong></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/9f6e8da5b232e8001a0272f4ef5249f98c36019d/201512/%E5%84%BF%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.PNG" alt="儿子-兄弟表示法"></p>
<p>儿子-兄弟 表示法 旋转45°，变成 二叉树</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/855520711dfedd3ed8d726039f5427185fee44fa/201512/%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt="二叉树"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据结构2-线性结构——2-4-应用实例：多项式加法运算" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/01/数据结构2-线性结构——2-4-应用实例：多项式加法运算/" class="article-date">
  	<time datetime="2015-12-01T12:08:39.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/数据结构2-线性结构——2-4-应用实例：多项式加法运算/">数据结构2-线性结构——2-4-应用实例：多项式加法运算</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="多项式加法运算">多项式加法运算</h1><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/28c464ba24c80ff65872b7460d67adc0b3054143/201512/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%971.PNG" alt="多项式加法运算1"></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/22c23cf33256038c38ac0d5b52042f04722c8774/201512/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E5%A4%9A%E9%A1%B9%E5%BC%8F.PNG" alt="单向链表表示多项式"></p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> PolyNode{
    <span class="keyword">int</span> coef;<span class="comment">//系数</span>
    <span class="keyword">int</span> expon;<span class="comment">//指数</span>
    <span class="keyword">struct</span> Node *link;<span class="comment">//指向下一个节点的指针</span>
}*Polynomial;
Polynomial P1,P2;
</code></pre><p><strong> 算法思路: </strong>两个指针P1，P2分别 指向 多项式 的第一个结点，不断循环：</p>
<ul>
<li>P1-&gt;expon==P2-&gt;expon:系数相加，若 结果不为0，则作为 结果多项式 对应项 的系数。同时，P1和P2都分别指向下一项；</li>
<li>P1-&gt;expon &gt; P2-&gt;expon:将P1的当前项 存入 结果多项式，并使P1指向下一项；</li>
<li>P1-&gt;expon &lt; P2-&gt;expon:将P2的当前项 存入 结果多项式，并使P2指向下一项。</li>
<li>当 某一个多项式 处理完时，将另一个多项式 的所有结点 依次复制到 结果多项式中去。</li>
</ul>
<hr>
<pre><code>Ploynomial PolyAdd(Polynomial P1, Polynomial P2){
    Polynomial front,rear,temp;<span class="comment">//front 记录 结果多项式 链表 头结点，rear 结果多项式 尾</span>
    int <span class="keyword">sum</span>;

    rear = (Polynomial)malloc(sizeof(PolyNode));<span class="comment">//为方便表头插入，先产生一个 临时空结点 作为 结果多项式 链表头</span>
    front = rear;

    <span class="keyword">while</span>(P1 <span class="subst">&amp;&amp;</span> P2){
        <span class="comment">//当两个多项式 都有 非零项 待处理时</span>
        switch(Compare(P1<span class="subst">-&gt;</span>expon, P2<span class="subst">-&gt;</span>expon)){
            <span class="keyword">case</span> <span class="number">1</span>:
                <span class="comment">//P1-&gt;expon &gt; P2-&gt;expon</span>
                Attach(P1<span class="subst">-&gt;</span>ceof, P1<span class="subst">-&gt;</span>expon, <span class="subst">&amp;</span>rear);<span class="comment">//将 P1的系数和指数 拷贝到结果多项式中，接到 rear的后边</span>
                P1 = P1<span class="subst">-&gt;</span><span class="keyword">link</span>;<span class="comment">//P1后移</span>
                break;
            <span class="keyword">case</span> -<span class="number">1</span>:
                Attach(P2<span class="subst">-&gt;</span>ceof, P2<span class="subst">-&gt;</span>expon, <span class="subst">&amp;</span>rear);
                P2=P2<span class="subst">-&gt;</span><span class="keyword">link</span>;
                break;
            <span class="keyword">case</span> <span class="number">0</span>:
                <span class="keyword">sum</span> = P1<span class="subst">-&gt;</span>ceof + P2<span class="subst">-&gt;</span>ceof;
                <span class="keyword">if</span>(<span class="keyword">sum</span>){
                    <span class="comment">//sum != 0</span>
                    Attach(<span class="keyword">sum</span>, P1<span class="subst">-&gt;</span>expon, <span class="subst">&amp;</span>rear);
                }
                P1=P1<span class="subst">-&gt;</span><span class="keyword">link</span>;
                P2=P2<span class="subst">-&gt;</span><span class="keyword">link</span>;
                break;
        }
    }
    <span class="comment">//将 未处理完的 另一个多项式 的所有节点 依次复制到 结果多项式 中</span>
    f<span class="subst">or</span>(; P1; P1=P1<span class="subst">-&gt;</span><span class="keyword">link</span>){
        <span class="comment">//P1 不空</span>
        Attach(P1<span class="subst">-&gt;</span>ceof, P1<span class="subst">-&gt;</span>ceof, <span class="subst">&amp;</span>rear);
    }
    f<span class="subst">or</span>(; P2; P2=P2<span class="subst">-&gt;</span><span class="keyword">link</span>){
        <span class="comment">//P2 不空</span>
        Attach(P2<span class="subst">-&gt;</span>ceof, P2<span class="subst">-&gt;</span>expon, <span class="subst">&amp;</span>rear);
    }

    rear<span class="subst">-&gt;</span><span class="keyword">link</span> = <span class="built_in">NULL</span>;<span class="comment">//rear 是结果多项式的尾，指向NULL</span>
    temp = front;
    front = front<span class="subst">-&gt;</span><span class="keyword">link</span>;<span class="comment">//令front指向 结果多项式 第一个 非零项</span>
    free(temp);<span class="comment">//释放临时 空表头结点</span>
    <span class="keyword">return</span> front;
}


<span class="literal">void</span> Attach(int ceof, int expon, Polynomial *PtrRear){
    <span class="comment">//ceof 系数，expon 指数，*PtrRear 结果多项式 尾指针</span>
    <span class="comment">//需要改变 结果多项式 尾指针的值，所以 第三个参数是 结点指针的地址，*PtrRear指向尾项</span>

    Polynomial P;

    P = (Polynomial)maoolc(sizeof(PolyNode))<span class="comment">//申请新结点</span>
    P<span class="subst">-&gt;</span>ceof = ceof;<span class="comment">//对新结点 赋值</span>
    P<span class="subst">-&gt;</span>expon = expon;
    (*PtrRear)<span class="subst">-&gt;</span><span class="keyword">link</span> = P;<span class="comment">//将P指向的 新结点 插入到 结果表达式 尾项 的后边</span>
    *PtrRear = P;<span class="comment">//修改PtrRear值</span>
}
</code></pre><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/aeb5358cf6062c54f5df5e2dd4711d7e06beef4f/201512/Attach%E5%87%BD%E6%95%B0.PNG" alt="Attach()图解，对新结点赋值"></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/aeb5358cf6062c54f5df5e2dd4711d7e06beef4f/201512/Attach%E5%87%BD%E6%95%B02.PNG" alt="Attach()图解，修改PtrRear值"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据结构2-线性结构——2-3-队列" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/01/数据结构2-线性结构——2-3-队列/" class="article-date">
  	<time datetime="2015-12-01T02:41:16.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/数据结构2-线性结构——2-3-队列/">数据结构2-线性结构——2-3-队列</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2-3-1_什么是队列">2.3.1 什么是队列</h1><h2 id="什么是队列">什么是队列</h2><p>队列：具有一定操作约束的线性表<br>插入、删除操作：只能在一端 插入，另一端 删除。<br>入队：数据插入<br>出队：数据删除<br>顺序：先来先服务、先进先出（FIFO）</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/f16d738b4e8aa70c3217a15c1d623677c50d26e0/201512/%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0.PNG" alt="队列的抽象数据类型描述"></p>
<h2 id="队列的顺序存储实现">队列的顺序存储实现</h2><p>由一个数组 和 记录 头元素位置 的变量 front 以及 一个 记录 尾元素位置 都变量 rear组成。</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> MaxSize&lt;存储数据元素的最大个数&gt;</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
    ElementType Data[MaxSize];
    <span class="keyword">int</span> rear;
    <span class="keyword">int</span> front;
}Queue;
</code></pre><p>没有元素时，front和rear都指向-1<br>第一个元素下表是0</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/88fc8cfc8dc7fddb8af1970ac1028e88df95312e/201512/%E9%A1%BA%E7%8E%AF%E9%98%9F%E5%88%971.PNG" alt="顺环队列1"></p>
<p>当没有元素时，front = rear = 0</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/9a66b8f4d28bfbda9608dc67e14df36b9253d53f/201512/%E9%A1%BA%E7%8E%AF%E9%98%9F%E5%88%972.PNG" alt="顺环队列2"></p>
<p>当前有5个元素，再添加一个元素，front = rear</p>
<p>思考：<br>    （1）这种方案，堆栈空和满 的判别条件是什么？<br>    （2）为什么会出现空、满 无法区分？根本原因是什么？<br>rear、front距离是[0, n-1].当前例子中，rear front的距离是[0,5]<br>当堆栈空，满时，距离都为0<br>根本原因：<br>rear、front距离[0,n-1]，共n种；<br>当前队列状态：空，1个元素，2个元素，3,4,5,6.共n+1种状态<br>用n种距离 表示不了 n+1种状态</p>
<p>解决方案：</p>
<ul>
<li>（1）使用 额外标记：Size或tag<br>Size标记元素个数，Size = 0时，队列空，Size为n时，队列满<br>tag，当rear=front，分不清是空还是满时，用tag标记最后一次操作，如果 插入，tag为1，删除tag为0.看最后一次操作的tag，判断是空还是满。</li>
<li>（2）仅使用n-1个数组空间，不放满。当前例子中，最多只放5个元素。</li>
</ul>
<p>采取第二种方案：</p>
<h2 id="(1)入队列">(1)入队列</h2><pre><code><span class="literal">void</span> AddQ(<span class="built_in">Queue</span> *PtrQ, ElementType item){
    <span class="keyword">if</span>((PtrQ<span class="subst">-&gt;</span>rear + <span class="number">1</span>) % MaxSize == PtrQ<span class="subst">-&gt;</span>front){
        printf(<span class="string">"队列满"</span>);
        <span class="keyword">return</span>;
    }
    PtrQ <span class="subst">-&gt; </span>rear = (PtrQ<span class="subst">-&gt;</span>rear + <span class="number">1</span>) % MaxSize;
    PtrQ <span class="subst">-&gt; </span><span class="built_in">Data</span><span class="preprocessor">[</span>PtrQ<span class="subst">-&gt;</span>rear<span class="preprocessor">]</span><span class="markup"> = item;
}</span>
</code></pre><h2 id="(2)出队列">(2)出队列</h2><pre><code>ElementType DeleteQ(<span class="built_in">Queue</span> *PtrQ){
    <span class="keyword">if</span>(PtrQ <span class="subst">-&gt; </span>front == PtrQ<span class="subst">-&gt;</span>rear){
        printf(<span class="string">"队列空"</span>);
        <span class="keyword">return</span> ERR<span class="subst">OR</span>;
    } <span class="keyword">else</span> {
        PtrQ<span class="subst">-&gt;</span>front = (PtrQ<span class="subst">-&gt;</span>front+<span class="number">1</span>)%MaxSize;
        <span class="keyword">return</span> PtrQ<span class="subst">-&gt;</span><span class="built_in">Data</span><span class="preprocessor">[</span>PtrQ<span class="subst">-&gt;</span>front<span class="preprocessor">]</span><span class="markup">;
    }
}</span>
</code></pre><h1 id="2-3-2_队列的_链式_存储实现">2.3.2 队列的 链式 存储实现</h1><p>可以用 单链表 实现。<br>插入和删除 操作 分别在 链表 的两头进行。<br>队列指针 front和rear 分别 指向链表的哪一头？<br>front是用来删除的，rear是用来插入的<br>链表的头，可以做front或rear，插入 删除都可以；<br>链表的尾，如果做front，删除了，就找不到链表的头了。<br>所以 链表的头做front，头做rear</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/4d566994a5d16091c1af0c8257fd3f6458b4763a/201512/%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0.PNG" alt="队列的链式存储实现"></p>
<pre><code><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>{
    ElementType Data;
    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *Next;
}QNode;
typedef struct</span>{
<span class="comment">//链队列结构</span>
QNode *rear;<span class="comment">//指向队尾结点</span>
QNode *front;<span class="comment">//指向队头结点</span>
}LinkQueue;
LinkQueue *PtrQ;
</code></pre><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/6f06be93324af5f8c6eb80abc68689bef6137f85/201512/%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B02.PNG" alt="队列的链式存储实现2"></p>
<h3 id="不带头结点_的链式队列_出队：">不带头结点 的链式队列 出队：</h3><pre><code>ElementType DeleteQ(LinkQueue *PtrQ){
    QNode *FrontCell;
    ElementType FrontElem;
    <span class="keyword">if</span>(PtrQ<span class="subst">-&gt;</span>front == <span class="built_in">NULL</span>){
        printf(<span class="string">"队列空"</span>);
        <span class="keyword">return</span> ERR<span class="subst">OR</span>;
    }
    FrontCell = PtrQ<span class="subst">-&gt;</span>front;
    <span class="keyword">if</span>(PtrQ<span class="subst">-&gt;</span>front == PtrQ<span class="subst">-&gt;</span>rear){
        <span class="comment">//队列只有一个元素</span>
        PtrQ<span class="subst">-&gt;</span>front = PtrQ<span class="subst">-&gt;</span>rear = <span class="built_in">NULL</span>;<span class="comment">//删除后 队列 置空</span>
    } <span class="keyword">else</span> {
        PtrQ<span class="subst">-&gt;</span>front = PtrQ<span class="subst">-&gt;</span>front<span class="subst">-&gt;</span>Next;
    }
    FrontElem = FrontCell<span class="subst">-&gt;</span><span class="built_in">data</span>;
    free(FrontCell);<span class="comment">//释放 被删除 结点 的空间</span>
    <span class="keyword">return</span> FrontElem;
}
</code></pre><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/67986e44fc4c058fae88bb70334e38474a23259c/201512/%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F.PNG" alt="不带头结点的链式队列出队"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据结构2-线性结构——2-2-堆栈" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/19/数据结构2-线性结构——2-2-堆栈/" class="article-date">
  	<time datetime="2015-11-19T11:37:25.000Z" itemprop="datePublished">2015-11-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/19/数据结构2-线性结构——2-2-堆栈/">数据结构2-线性结构——2-2-堆栈</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2-2-1">2.2.1</h1><h2 id="什么是堆栈？">什么是堆栈？</h2><h3 id="算术表达式">算术表达式</h3><ul>
<li>组成<ul>
<li>运算数：1,2,3</li>
<li>运算符号：+，-，*，/</li>
</ul>
</li>
</ul>
<h3 id="后缀表达式">后缀表达式</h3><ul>
<li>中缀表达式：运算符号位于两个运算数之前。a+b*c-d/e</li>
<li>后缀表达式：运算符号位于两个运算数之后。abc*+de/-</li>
</ul>
<p>计算：62/3-42*+=?<br>后缀表达式求值策略：从左往右扫描，逐个处理运算数和运算符号。<br>1.遇到运算数先记住<br>2.遇到运算符，将与运算符挨着的2个运算数计算<br>答案是8，T(n)=O(n)</p>
<p>用什么数据结构存储后缀表达式？<br>需要一种存储方法，能顺序存储运算数，并在需要时倒序输出。<br>堆栈</p>
<h3 id="堆栈的抽象数据类型描述">堆栈的抽象数据类型描述</h3><p>堆栈：具有一定操作约束的线性表<br>   只在一端（栈顶，Top）做插入删除</p>
<ul>
<li>入栈：插入数据</li>
<li>出栈：删除数据</li>
<li>顺序：后入先出（Last In First Out ，LIFO）</li>
</ul>
<h3 id="堆栈的抽象数据类型描述-1">堆栈的抽象数据类型描述</h3><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/c6b2f97e2f2c4ac5b3d78d2e79304552f3801121/2015111/%E5%A0%86%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0.PNG" alt="堆栈的抽象数据类型描述"></p>
<h1 id="2-2-2_栈的顺序存储实现">2.2.2 栈的顺序存储实现</h1><p>通常由一个一维数组和一个记录栈顶元素位置的变量组成</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> MaxSize&lt;储存数据元素的最大个数&gt;</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
    ElementType Data[MaxSize];
    <span class="keyword">int</span> Top;
}Stack;
</code></pre><h2 id="(1)入栈">(1)入栈</h2><pre><code><span class="literal">void</span> Push(<span class="built_in">Stack</span> *PtrS, ElementType item){
    <span class="keyword">if</span>(Ptrs <span class="subst">-&gt; </span>Top == MaxSize - <span class="number">1</span>){
        printf(<span class="string">"堆栈满"</span>);
        <span class="keyword">return</span>;
    } <span class="keyword">else</span> {
        PtrS <span class="subst">-&gt; </span><span class="built_in">Data</span><span class="preprocessor">[</span>++(PtrS <span class="subst">-&gt; </span>Top)<span class="preprocessor">]</span><span class="markup"> = item;
        return;
    }
}</span>
</code></pre><h2 id="(2)出栈">(2)出栈</h2><pre><code>ElementType Pop(<span class="built_in">Stack</span> *PtrS){
    <span class="keyword">if</span>(PtrS <span class="subst">-&gt; </span>Top == -<span class="number">1</span>){
        printf(<span class="string">"堆栈空"</span>);
        <span class="keyword">return</span> ERR<span class="subst">OR</span>;<span class="comment">//ERROR是ElementType的特殊值，标志错误</span>
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> (PtrS <span class="subst">-&gt; </span><span class="built_in">Data</span><span class="preprocessor">[</span>(PtrS <span class="subst">-&gt; </span>Top)--<span class="preprocessor">]</span><span class="markup">);
    }
}</span>
</code></pre><h2 id="[例]请用一个数组实现两个堆栈，要求最大地利用数组空间，使数组只要有空间入栈操作就可以成功。">[例]请用一个数组实现两个堆栈，要求最大地利用数组空间，使数组只要有空间入栈操作就可以成功。</h2><p>[分析]两个栈 分别从 数组的两头开始 向中间生长，当两个栈的 栈顶指针相遇时，两个栈都满了。</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> MaxSize&lt;存储数据元素的最大个数&gt;</span>
<span class="keyword">struct</span> DStack{
    ElementType Data[MaxSize];
    <span class="keyword">int</span> Top1;<span class="comment">//堆栈1的栈顶指针</span>
    <span class="keyword">int</span> Top2;<span class="comment">//堆栈2的栈顶指针    </span>
}S;
<span class="comment">//堆栈空</span>
S.Top1 = -<span class="number">1</span>;
S.Top2 = MaxSize;
</code></pre><h3 id="(1)入栈-1">(1)入栈</h3><pre><code><span class="literal">void</span> Push(struce DStack *PtrS, ElementType item, int <span class="built_in">Tag</span>){
    <span class="comment">//Tag作为区分两个堆栈的标志，取值为1,和2</span>
    <span class="keyword">if</span>(PtrS <span class="subst">-&gt; </span>Top2 - PtrS <span class="subst">-&gt; </span>Top1 == <span class="number">1</span>){
        printf(<span class="string">"堆栈满"</span>);
        <span class="keyword">return</span>;            
    }
    <span class="keyword">if</span>(<span class="built_in">Tag</span> == <span class="number">1</span>){
        <span class="comment">//对 堆栈1操作</span>
        PtrS <span class="subst">-&gt; </span><span class="built_in">Data</span><span class="preprocessor">[</span>++(PtrS <span class="subst">-&gt; </span>Top1)<span class="preprocessor">]</span><span class="markup"> = item;
    } else {
        //对 堆栈2操作
        PtrS -&gt; Data</span><span class="preprocessor">[</span>--(PtrS <span class="subst">-&gt; </span>Top2)<span class="preprocessor">]</span><span class="markup"> = item;
    }
}</span>
</code></pre><h3 id="(2)出栈-1">(2)出栈</h3><pre><code><span class="function">ElementType <span class="title">Pop</span><span class="params">(<span class="keyword">struct</span> DStack *PtrS, <span class="keyword">int</span> Tag)</span></span>{
    <span class="comment">//Tag作为区分两个堆栈的标志，取值为1,和2</span>
    <span class="keyword">if</span>(Tag == <span class="number">1</span>){
        <span class="comment">//对 堆栈1操作</span>
        <span class="keyword">if</span>(PtrS -&gt; Top1 == -<span class="number">1</span>){
            <span class="built_in">printf</span>(<span class="string">"堆栈1空"</span>);
            <span class="keyword">return</span> <span class="literal">NULL</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> PtrS -&gt; Data[(PtrS -&gt; Top1)--];
        }
    } <span class="keyword">else</span> {
        <span class="comment">//对 堆栈2操作</span>
        <span class="keyword">if</span>(PtrS -&gt; Top2 == MaxSize){
            <span class="built_in">printf</span>(<span class="string">"堆栈2空"</span>);
            <span class="keyword">return</span> <span class="literal">NULL</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> PtrS -&gt; Data[(PtrS -&gt; Top2)++];
        }
    }
}
</code></pre><h1 id="2-2-3_堆栈的链式存储实现">2.2.3 堆栈的链式存储实现</h1><p>栈的链式存储结构 是 一个单向链表，叫做 链栈。<br>插入和删除操作 只能在 链栈 的栈顶进行。</p>
<pre><code>typedef struct <span class="keyword">Node</span><span class="identifier"></span><span class="title">{
    ElementType</span> Data;
    struct <span class="keyword">Node</span><span class="identifier"> </span><span class="title">*Next</span>;
}LinkStack;
LinkStack *Top;
</code></pre><h2 id="(1)堆栈初始化（建立空栈）">(1)堆栈初始化（建立空栈）</h2><pre><code><span class="function">LinkStack *<span class="title">createStack</span><span class="params">()</span></span>{
    <span class="comment">//构建 一个堆栈 的头结点，返回指针</span>
    LinkStack *S;
    S = (LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));
    S -&gt; Next = <span class="literal">NULL</span>;
    <span class="keyword">return</span> S;
}
</code></pre><h2 id="(2)判断_堆栈S_是否为空">(2)判断 堆栈S 是否为空</h2><pre><code><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(LinkStack *S)</span></span>{
    <span class="comment">//空 返回1，非空 返回0</span>
    <span class="keyword">return</span> (S -&gt; Next == <span class="literal">NULL</span>);
}
</code></pre><h2 id="(3)入栈">(3)入栈</h2><pre><code>void Push(ElementType item, LinkStack *S){
    //将item 压入 堆栈S
    struct <span class="keyword">Node</span><span class="identifier"> </span><span class="title">*TmpCell</span>;
    TmpCell = maoolc(sizeof(struct <span class="keyword">Node</span><span class="identifier"></span><span class="title">));
    TmpCell</span> -&gt; Element = item;
    TmpCell -&gt; Next = S -&gt; Next;
    S -&gt; Next = TmpCell;
}
</code></pre><h2 id="(4)出栈">(4)出栈</h2><pre><code><span class="function">ElementType <span class="title">Pop</span><span class="params">(LinkStack *S)</span></span>{
    <span class="comment">//删除栈顶元素 并返回S的栈顶元素</span>
    <span class="keyword">struct</span> Node *FirstCell;
    ElementType TopElem;
    <span class="keyword">if</span>(IsEmpty(S)){
        <span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    } <span class="keyword">else</span> {
        FirstCell = S -&gt; Next;
        S -&gt; Next = FirstCell -&gt; Next;
        TopElem = FirstCell -&gt; Element;
        <span class="built_in">free</span>(FirstCell);
        <span class="keyword">return</span> TopElem;
    }
}
</code></pre><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/50c806146d26ab39f4746441a4d003e959b53f75/201512/%E9%93%BE%E6%A0%88%E5%87%BA%E6%A0%88.PNG" alt="链栈出栈"></p>
<h1 id="2-2-4_堆栈应用：表达式求值">2.2.4 堆栈应用：表达式求值</h1><ul>
<li>回忆 堆栈 实现 后缀表达式 求值：<br>  从左到右 读入 后缀表达式 的各项（运算数 或 运算符）<ul>
<li>1.运算数：入栈</li>
<li>2.运算符：从 堆栈中 弹出 适当数量 的运算数，计算并结果入栈</li>
<li>3.最后，栈顶元素 就是表达式的结果值</li>
</ul>
</li>
</ul>
<h2 id="中缀表达式求值">中缀表达式求值</h2><p><strong> 基本策略 </strong>：将中缀表达式 转换为 后缀表达式，求值<br>[例子]: 2+9/3-5  后缀表达式为：293/+5-</p>
<ul>
<li>1.运算数相对顺序不变</li>
<li>2.运算符号顺序改变<ul>
<li>需要存储“等待中”的运算符号</li>
<li>将当前运算符号 与 “等待中” 的 后一个运算符号 比较</li>
</ul>
</li>
</ul>
<p>[例]a<em>(b+c)/d  后缀表达式： abc+</em>d/</p>
<p><strong> 中缀表达式 如何 转换为 后缀表达式 </strong><br>从头到尾读取 中缀表达式的每个对象，不同对象做不同处理：</p>
<ul>
<li>1.运算数：直接输出；</li>
<li>2.左括号：压入堆栈</li>
<li>3.右括号：将栈顶的运算符弹出并输出，直到遇到左括号（左括号直接出栈，不输出）</li>
<li>4.运算符<ul>
<li>优先级 大于 栈顶运算符，则压入栈；</li>
<li>优先级 小于等于 栈顶运算符，将 栈顶运算符 弹出并输出；再比较 新的栈顶运算符，直到该运算符 优先级 大于 栈顶运算符 为止，然后将 该运算符压入栈；</li>
</ul>
</li>
<li>5.若各对象处理完毕，把堆栈中 存留的 运算符 一并输出</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/7048bcb80f4d516667bba3a82f6251df20303ae3/201512/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BE%8B%E5%AD%90.PNG" alt="中缀表达式 转为 后缀表达式 例子"></p>
<p><strong> 堆栈的其他应用 </strong></p>
<ul>
<li>函数调用 及 递归 实现</li>
<li>深度优先搜索</li>
<li>回溯算法</li>
<li>……</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据结构2-线性结构——2-1-线性表及其实现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/16/数据结构2-线性结构——2-1-线性表及其实现/" class="article-date">
  	<time datetime="2015-11-16T11:53:17.000Z" itemprop="datePublished">2015-11-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/16/数据结构2-线性结构——2-1-线性表及其实现/">数据结构2 线性结构——2-1 线性表及其实现 </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="2-1-1">2.1.1</h3><h3 id="多项式的表示">多项式的表示</h3><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/1c2f096c03766550961019c7f3be6e9c9a198c1e/2015111/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA.PNG" alt="多项式的表示"></p>
<h4 id="方法1：顺序存储结构直接表示">方法1：顺序存储结构直接表示</h4><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/0996938c807601aad044797fb63b9a48c37e2e29/2015111/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9B%B4%E6%8E%A5%E8%A1%A8%E7%A4%BA.PNG" alt="顺序存储结构直接表示"><br>x+3x^2000,需要2001项，只有2项非零，造成极大浪费。</p>
<h4 id="方法2：顺序存储结构表示非零项">方法2：顺序存储结构表示非零项</h4><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/b626e3693e6a58ad4019b4b8e16b7f5988842523/2015111/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%A1%A8%E7%A4%BA%E9%9D%9E%E9%9B%B6%E9%A1%B9.PNG" alt="顺序存储结构表示非零项"><br>按 指数大小 有序存储<br><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/f884bc9330b731b93103338be1f6fcd854a115d7/2015111/%E9%9D%9E%E9%9B%B6%E9%A1%B9%E7%9B%B8%E5%8A%A0%E8%BF%87%E7%A8%8B.PNG" alt="相加过程"></p>
<h4 id="方法3：链表结构存储非零项">方法3：链表结构存储非零项</h4><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/cc0cc93d09bd014817018dd8579535f4dccc7451/2015111/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E9%9D%9E%E9%9B%B6%E9%A1%B9.PNG" alt="链表结构存储非零项"></p>
<h3 id="什么是线性表">什么是线性表</h3><ul>
<li><p>多项式表示问题的启示：</p>
<ul>
<li>1.同一个问题可以有不同的表示（存储）方式</li>
<li>2.有一类共性问题：有序线性序列的组织和管理</li>
</ul>
</li>
<li><p>线性表：由同类型数据元素构成有序序列的线性结构</p>
<ul>
<li>长度：表中元素个数</li>
<li>空表：线性表中没有元素</li>
<li>表头：表起始位置；表尾：表结束位置</li>
</ul>
</li>
</ul>
<h4 id="线性表的抽象数据类型描述">线性表的抽象数据类型描述</h4><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/9de69a0f97c39a1666f7b1f7e0ab4e2a9706547e/2015111/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0.PNG" alt="线性表的抽象数据类型描述"></p>
<h4 id="线性表的顺序存储实现">线性表的顺序存储实现</h4><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/76a97e03faa9953d0d2ffef0d2ea3a4f721d3212/2015111/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0.PNG" alt="线性表的顺序存储实现"></p>
<h4 id="主要操作的实现">主要操作的实现</h4><p><strong> 1.初始化（建立空的顺序表） </strong></p>
<pre><code><span class="built_in">List</span> *MakeEmpty(){
    <span class="built_in">List</span> *PtrL;
    PtrL = (<span class="built_in">List</span>*)malloc(sizeof(<span class="built_in">List</span>));
    PtrL<span class="subst">-&gt;</span>Last = -<span class="number">1</span>;
    <span class="keyword">return</span> PtrL;
}
</code></pre><p><strong> 2.查找 </strong></p>
<pre><code><span class="keyword">int</span> find(ElementType X, <span class="keyword">List</span> *PtrL){
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">while</span>(i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!=X){
        i++;
    }
    <span class="keyword">if</span>(i &gt; PtrL-&gt;Last){
        <span class="keyword">return</span> -<span class="number">1</span>;
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> i;<span class="comment">//找到后返回存储位置</span>
    }
}
</code></pre><p>查找成功的平均次数为(n+1)/2，平均时间性能为O(n)</p>
<p><strong> 3.插入：第i( l&lt;=i &lt;= n+1)个位置上插入一个值为X的新元素 </strong><br>下表是i-1的位置赋值为X，下表i到SIZE-1的部分右移。<br>右移时应从右往左操作。</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X, <span class="keyword">int</span> i, List *PtrL)</span></span>{
    <span class="keyword">int</span> j;
    <span class="keyword">if</span>(PtrL-&gt;Last == MAXSIZE - <span class="number">1</span>){
        <span class="built_in">printf</span>(<span class="string">"表满"</span>);
        <span class="keyword">return</span>;
    }

    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; PtrL -&gt; Last +<span class="number">2</span>){
        <span class="built_in">printf</span>(<span class="string">"位置不合法"</span>);
        <span class="keyword">return</span>;
    }

    <span class="keyword">for</span>(j = PtrL-&gt;Last; j &gt;= i - <span class="number">1</span>; j--){
        PtrL-&gt;Data[j + <span class="number">1</span>] = PtrL-&gt;Data[j];<span class="comment">//对a[i]-a[n]倒序赋值</span>
    }
    PtrL-&gt;Data[i -<span class="number">1</span>] = X;<span class="comment">//插入新元素</span>
    PtrL-&gt;Last++;<span class="comment">//Last指向最后元素</span>
    <span class="keyword">return</span>;
}
</code></pre><p><strong> 4.删除：删除表的第i( l &lt;= i &lt;= n)个位置上的元素 </strong><br>删除下表为i-1的元素，后边的元素全部前移一个位置。从左往右移</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i, List *PtrL)</span></span>{
    <span class="keyword">int</span> j;
    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; PtrL -&gt; Last +<span class="number">1</span>){
        <span class="built_in">printf</span>(<span class="string">"不存在第%d个元素"</span>， i);
        <span class="keyword">return</span>;
    }

    <span class="keyword">for</span>(j = i; i &lt;= PtrL -&gt; Last; j++){
        PtrL -&gt; Data[j - <span class="number">1</span>] = PtrL -&gt; Data[j];<span class="comment">//将a[i+1]到a[n]顺序向前移动</span>
    }
    PtrL-&gt; Last--;<span class="comment">//Last指向最后一个元素</span>
    <span class="keyword">return</span>;
}
</code></pre><p>平均移动次数是(n-1)/2<br>平均时间性能为O(n)</p>
<h4 id="线性表的链式存储实现">线性表的链式存储实现</h4><p>不要求 逻辑上相邻 的两个元素 物理上也相邻：通过 “链” 建立起数据元素之间的逻辑关系。<br>数组是逻辑相邻，且物理相邻的。<br>节点表示：</p>
<pre><code>typedef struct <span class="keyword">Node</span><span class="identifier"></span><span class="title">{
    ElementType</span> Data;//节点的数据
    struct <span class="keyword">Node</span><span class="identifier"> </span><span class="title">*Next</span>;//下一个节点的位置
}List;
List L, *PtrL;
</code></pre><h4 id="主要操作的实现-1">主要操作的实现</h4><p><strong> 1.求表长 </strong></p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List *PtrL)</span></span>{
    List *p = PtrL;<span class="comment">//p指向表的第一个节点</span>
    <span class="keyword">int</span> j = <span class="number">0</span>;
    <span class="keyword">while</span>(p){
        p = p -&gt; Next;
        j++; <span class="comment">//当前p指向第j个节点</span>
    }
    <span class="keyword">return</span> j;
}
</code></pre><p>时间性能为O(n)</p>
<p><strong> 2.查找 </strong><br>(1)按序号查找：FindKth</p>
<pre><code><span class="keyword">List</span> *FindKth( <span class="keyword">int</span> K, <span class="keyword">List</span> *PtrL){
    <span class="keyword">List</span> *p = PtrL;
    <span class="keyword">int</span> i = <span class="number">1</span>;
    <span class="keyword">while</span>( p != <span class="keyword">NULL</span> &amp;&amp; i &lt; K){
        p = p -&gt; Next;
        i++;
    }

    <span class="keyword">if</span>( i == k){
        <span class="keyword">return</span> p;<span class="comment">//找到第k个，返回指针</span>
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> <span class="keyword">NULL</span>;
    }
}
</code></pre><p>(2)按值查找：Find</p>
<pre><code><span class="built_in">List</span> *Find(ElementType X, <span class="built_in">List</span> *PtrL){
    <span class="built_in">List</span> *p = PtrL;
    <span class="keyword">while</span>(p != <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> p <span class="subst">-&gt; </span><span class="built_in">Data</span> != X){
        p = p <span class="subst">-&gt; </span>Next;
    }
    <span class="keyword">return</span> p;
}
</code></pre><p>平均时间性能为O(n)</p>
<p>** 3.插入（在低 i-1( 1&lt;=i&lt;=n+1)个结点后插入一个值为X的新结点）</p>
<ul>
<li>1.先构造一个新结点，用s指向；</li>
<li>2.再找到链表的第i-1个结点，用p指向；</li>
<li>3.然后修改指针，插入结点（p之后插入新结点是s）</li>
<li><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/31a5daa88866f66dc765befe747b7c30616630dc/2015111/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.PNG" alt="链表插入"> </li>
</ul>
<pre><code><span class="built_in">List</span> *Insert(ElementType X, int i, <span class="built_in">List</span> *PtrL){
    <span class="built_in">List</span> *p, *s;
    <span class="keyword">if</span>(i == <span class="number">1</span>){
        <span class="comment">//新结点插入在表头</span>
        s = (<span class="built_in">List</span> *)malloc(sizeof(<span class="built_in">List</span>));<span class="comment">//申请空间，填装结点</span>
        s <span class="subst">-&gt; </span><span class="built_in">Data</span> = X;
        s <span class="subst">-&gt; </span>Next = PtrL;
        <span class="keyword">return</span> s;<span class="comment">//返回新表头指针</span>
    }

    p = FindKth(i -<span class="number">1</span>, PtrL);<span class="comment">//查找第i-1个结点</span>
    <span class="keyword">if</span>(p == <span class="built_in">NULL</span>){
        printf(<span class="string">"第i-1个不存在，不能插入"</span>);
        <span class="keyword">return</span> <span class="built_in">NULL</span>;
    }<span class="keyword">else</span>{
        s = (<span class="built_in">List</span> *)malloc(sizeof(<span class="built_in">List</span>));<span class="comment">//申请空间，填装结点</span>
        s <span class="subst">-&gt; </span><span class="built_in">Data</span> = X;
        s <span class="subst">-&gt; </span>Next = p <span class="subst">-&gt; </span>Next;<span class="comment">//新结点插入在第i-1个结点后边</span>
        p <span class="subst">-&gt; </span>Next = s;
        <span class="keyword">return</span> PtrL;
    }
}
</code></pre><p>** 4.删除（删除链表的第i( 1&lt;=i&lt;=n)个位置上的结点）</p>
<ul>
<li>1.先找到链表的第i-1个结点，用p指向；</li>
<li>2.再用指针s指向要被删除的结点（p的下一个结点）</li>
<li>3.然后修改指针，删除s所指向的结点 </li>
<li>4.最后释放s所指结点的空间<br><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/0b7f552537b3d0d6bd4a7c7c4618a495c907b63c/2015111/%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4.PNG" alt="链表删除"></li>
</ul>
<pre><code><span class="function">List *<span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i, List *PtrL)</span></span>{
    List *p, *s;
    <span class="keyword">if</span>(i == <span class="number">1</span>){
        <span class="comment">//删除表的第一个结点</span>
        s = PtrL;<span class="comment">//s指向第1个结点</span>
        <span class="keyword">if</span>(PtrL != <span class="literal">NULL</span>){
            PtrL = PtrL -&gt; Next;
        }<span class="keyword">else</span>{
            <span class="keyword">return</span> <span class="literal">NULL</span>;
        }
        <span class="built_in">free</span>(s);
        <span class="keyword">return</span> PtrL;
    }

    p = FindKth(i - <span class="number">1</span>, PtrL);<span class="comment">//查找第i-1个结点</span>
    <span class="keyword">if</span>(p == <span class="literal">NULL</span>){
        <span class="built_in">printf</span>(<span class="string">"第%d个结点不存在"</span>, i - <span class="number">1</span>);
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    }<span class="keyword">else</span> <span class="keyword">if</span>(p -&gt; Next == <span class="literal">NULL</span>){
        <span class="built_in">printf</span>(<span class="string">"第%d个结点不存在"</span>, i);
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    }<span class="keyword">else</span>{
        s = p -&gt; Next;<span class="comment">//s指向第i个结点</span>
        p -&gt; Next = s -&gt; Next;<span class="comment">//从链表删除</span>
        <span class="built_in">free</span>(s);<span class="comment">//释放被删除的结点</span>
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    }
}
</code></pre><p>平均查找次数是n/2<br>平均时间性能是O(n)</p>
<h4 id="广义表">广义表</h4><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/d9fa830fe28e07674fbefc8471ce35632e049d6b/2015111/%E5%B9%BF%E4%B9%89%E8%A1%A8.PNG" alt="广义表"></p>
<p><strong> 广义表： </strong></p>
<ul>
<li>是线性表的推广</li>
<li>对于线性表，n个元素都是基本的单元素</li>
<li>广义表中，这些元素不仅可以是单元素也可以是另一个广义表</li>
</ul>
<pre><code>typedef <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>{</span>
    int <span class="constant">Tag</span>;<span class="regexp">//</span>标志域：<span class="number">0</span>表示结点是单元素，<span class="number">1</span>表示结点是广义表
    <span class="class"><span class="keyword">union</span>{</span>
        /<span class="regexp">/子表指针域Sublist与单元素数据域Data复用，即共用存储空间
        ElementType Data;
        struct GNode *SubList;
    }URegion;
    struct GNode *Next;/</span><span class="regexp">/指向后继结点
}GList;</span>
</code></pre><p>通过Tag来确认数据是Data还是SubList</p>
<p><strong> 多重链表 </strong><br>多重链表：链表中的节点可能同时隶属于多个链</p>
<ul>
<li>多重链表中结点的指针域会有多个，如前面例子包含了Next和SubList两个指针域</li>
<li>但包含两个指针域的链表并不一定是多重链表，比如在双向链表不是多重链表</li>
</ul>
<p><strong> 多重链表的用途 </strong><br>树、图 这样相对复杂的数据结构都可以采用多重链表的方式存储</p>
<p><strong> 多重链表表示稀疏矩阵 </strong><br><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/9f84e90dfb17d2d28890f98e260c3943cb0c51ed/2015111/%E7%9F%A9%E9%98%B5.PNG" alt="矩阵"></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/9f84e90dfb17d2d28890f98e260c3943cb0c51ed/2015111/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.PNG" alt="十字链表"></p>
<p>Head是行或列的头结点<br><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/9f84e90dfb17d2d28890f98e260c3943cb0c51ed/2015111/%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.PNG" alt="入口结点"><br>Term是稀疏矩阵的非零项<br>左上角的Term结点，是入口结点，表示有4行5列，7个非零项</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/9f84e90dfb17d2d28890f98e260c3943cb0c51ed/2015111/union%E6%95%B4%E5%90%88term_head.PNG" alt="Union整合Term和Head"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据结构1 基本概念——1-3最大子列和问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/16/数据结构1 基本概念——1-3最大子列和问题/" class="article-date">
  	<time datetime="2015-11-16T01:06:35.000Z" itemprop="datePublished">2015-11-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/16/数据结构1 基本概念——1-3最大子列和问题/">数据结构1 基本概念——1-3最大子列和问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-最大子列和问题">1.最大子列和问题</h3><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/54256bbe25da63466c83cf5045f48b6461a3d9ba/2015111/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C.PNG" alt="最大子列和"></p>
<p><strong> 算法1 </strong></p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum1</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span>{
    <span class="keyword">int</span> ThisSum, MaxSum = <span class="number">0</span>;
    <span class="keyword">int</span> i, j, k;
    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++){
        <span class="keyword">for</span>(j = i; j &lt; N; j++){
            ThisSum = <span class="number">0</span>;
            <span class="keyword">for</span>(k = i; k &lt;=j; k++){
                ThisSum += A[k];
                <span class="keyword">if</span>(ThisSum &gt; MaxSum)
                    MaxSum = ThisSum;
            }
        }<span class="comment">//j循环结束</span>
    }<span class="comment">//i循环结束</span>
    <span class="keyword">return</span> MaxSum;
}
</code></pre><p>复杂度 T(N) = O(N^3)</p>
<p><strong> 算法2 </strong></p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span>{
    <span class="keyword">int</span> ThisSum, MaxSum = <span class="number">0</span>;
    <span class="keyword">int</span> i, j;
    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++){
        ThisSum = <span class="number">0</span>;
        <span class="keyword">for</span>(j = i; j &lt; N; j++){
            ThisSum += A[j];<span class="comment">//对于相同的i，不同的j，只要在j-1次循环的基础上累加1即可</span>
            <span class="keyword">if</span>(ThisSum &gt; MaxSum){
                MaxSum = ThisSum;
            }
        }
    }
    <span class="keyword">return</span> MaxSum;
}
</code></pre><p>复杂度 T(N) = O(N^2)</p>
<p><strong> 算法3：分而治之 </strong></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/5ea20416e949700f79ef7a9c55234674a18b8f34/2015111/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B.PNG" alt="分而治之"></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/36a3a0330c1b382d780067f85154bd09e1168ca2/2015111/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B2.PNG" alt="分而治之举例"></p>
<p><strong> 算法4:在线处理 </strong></p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum4</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span>{
    <span class="keyword">int</span> ThisSum, MaxSum;
    <span class="keyword">int</span> i;
    ThisSum = MaxSum = <span class="number">0</span>;
    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++){
        ThisSum += A[i];<span class="comment">//向右累加</span>
        <span class="keyword">if</span>(ThisSum &gt; MaxSum){
            MaxSum = ThisSum;<span class="comment">//发现更大的，更新当前结果</span>
        }<span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>){
            ThisSum = <span class="number">0</span>;<span class="comment">//不能使后边的部分和增大，抛弃</span>
            }
    }
    <span class="keyword">return</span> MaxSum;
}
</code></pre><p>T(N) = O(N)<br>举例[-1,3，-2,4，-6,1,6，-1]<br>MaxSum = 7</p>
<p>“在线”的意思是指 每输入一个数据 就进行 及时处理，在任何一个地方中止输入，算法都能正确给出当前的解。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据结构1 基本概念——1-2什么是算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/10/数据结构1 基本概念——1-2什么是算法/" class="article-date">
  	<time datetime="2015-11-10T01:21:45.000Z" itemprop="datePublished">2015-11-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/10/数据结构1 基本概念——1-2什么是算法/">数据结构1 基本概念——1-2什么是算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本概念">基本概念</h1><h2 id="1-2什么是算法？">1.2什么是算法？</h2><h3 id="1-算法">1.算法</h3><ul>
<li>一个有限指令集</li>
<li>接受一些输入（有些情况下不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤后终止</li>
<li>每一条指令必须<ul>
<li>有充分明确的目标，不可以有歧义</li>
<li>计算机能处理的范围之内</li>
<li>描述应该抽象，不依赖于任何一种计算机语言以及具体实现手段</li>
</ul>
</li>
</ul>
<h3 id="例1-选择排序算法的伪码描述">例1.选择排序算法的伪码描述</h3><pre><code><span class="keyword">void</span> SelectionSort(<span class="built_in">int</span> <span class="built_in">List</span>[], <span class="built_in">int</span> N)
{
    <span class="comment">/*将N个整数List[0]...List[N - 1] 进行从小到大排序*/</span>
    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++){
        MinPosition = ScanForMin(<span class="built_in">List</span>, i, N - <span class="number">1</span>);
        <span class="comment">/*从List[i]到List[N - 1]中找最小元，并将其位置赋给MinPosition*/</span>
        Swap(<span class="built_in">List</span>[i], <span class="built_in">List</span>[MinPosition]);
        <span class="comment">/*将未排序部分的最小元换到有序部分的最后位置*/</span>
    }
}
</code></pre><p>抽象的体现：</p>
<pre><code>-<span class="ruby"> <span class="constant">List</span>是数组还是链表？
</span>-<span class="ruby"> <span class="constant">Swap</span>用函数还是用宏去实现？</span>
</code></pre><h3 id="2-什么是好的算法？">2.什么是好的算法？</h3><ul>
<li>空间复杂度S(n) —— 根据算法写成的程序在执行时 占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。</li>
<li>时间复杂度T(n) —— 根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间负责度过高的低效算法可能导致我们在有生之年都等不到运行结果。</li>
</ul>
<h3 id="1-1_例2_递归打印出1-N">1.1 例2 递归打印出1-N</h3><pre><code><span class="function"><span class="keyword">void</span> <span class="title">PrintN</span><span class="params">(<span class="keyword">int</span> N)</span>
</span>{
    <span class="keyword">if</span>(N){
        PrintN(N - <span class="number">1</span>);
        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, N);
    }
    <span class="keyword">return</span>;
}
</code></pre><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/fda4725e78496f986a4ecef9cf662f55721bfd24/2015111/%E9%80%92%E5%BD%92%E6%89%93%E5%8D%B0%E5%A4%8D%E6%9D%82%E5%BA%A6.PNG" alt="递归复杂度"></p>
<p>S(N)= CN,空间复杂度是一个N的函数，C是一个常亮，空间复杂度随着N的增加而变大。<br>每个程序可用空间有限，当N很大，需要的空间大于当前程序拥有的空间时，程序异常退出。不能输出正确结果。</p>
<h3 id="1-1_例3_多项式求值">1.1 例3 多项式求值</h3><pre><code><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> a[], <span class="keyword">double</span> x)</span>
</span>{
    <span class="keyword">int</span> i;
    <span class="keyword">double</span> p = a[<span class="number">0</span>];
    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++){
        p += (a(i) * <span class="built_in">pow</span>(x, i));
    }
    <span class="keyword">return</span> p;
}
</code></pre><p>执行了多少次乘法？<br>for循环执行了n次，<br>pow(x,i)是求x的i次方，执行了i-1次乘法，<br>每一次循环中，执行了i次乘法。<br>一共执行了(1+2+…+n) = (n ^2 + n) / 2 次乘法。<br>时间复杂度 T(n) = C1 n^2 + C2 n</p>
<hr>
<pre><code><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> a[], <span class="keyword">double</span> x)</span>
</span>{
    <span class="keyword">int</span> i;
    <span class="keyword">double</span> p = a[n];
    <span class="keyword">for</span>(i = n; i &gt; <span class="number">0</span>; i--){
        p = a[i - <span class="number">1</span>] + x * p;
    }
    <span class="keyword">return</span> p;
}
</code></pre><p>执行了多少次乘法？<br>每次循环执行1次乘法，执行了n次循环，一共执行了n次乘法。<br>时间复杂度 T(n) = C n</p>
<h3 id="什么是最好的算法？">什么是最好的算法？</h3><ul>
<li>在分析一般算法的效率时，我们经常关注下边两种复杂度<ul>
<li>最坏情况复杂度 T worst (n)</li>
<li>平均复杂度 T avg (n)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/cba4f701419095c52a853a42825a2b8512acce76/2015111/%E5%85%B3%E6%B3%A8%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6.PNG" alt="关注的复杂度"></p>
<p>我们更关注T worst</p>
<h3 id="复杂度的渐进表示法">复杂度的渐进表示法</h3><p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/ba5e3e91c45d632d6c88dbbe9f7e4c8ed8388810/2015111/%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA.PNG" alt="复杂度渐进表示"></p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/304c7259057cbbadb315548c6e411a674670a743/2015111/%E8%BE%93%E5%85%A5%E8%A7%84%E6%A8%A1.PNG" alt="输入规模"></p>
<p>设计函数要避免出现n!</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/304c7259057cbbadb315548c6e411a674670a743/2015111/%E5%87%BD%E6%95%B0%E5%9B%BE.PNG" alt="函数图"><br>增长率高的函数尽量转化为增长率低的函数</p>
<p><img src="https://raw.githubusercontent.com/FloraJieQiong/pages-pics/c6c2b2a01384bd60305f77ebbcad1421735fe187/2015111/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%AA%8D%E9%97%A8.PNG" alt="复杂度分析窍门"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 John Doe
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>